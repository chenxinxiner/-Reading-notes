# 深入理解计算机组成原理

## 程序结构和执行

### 1 信息的表示和处理

### 1.1 信息存储

+ 我们将程序称为“32位程序”或“64位程序”时，区别是该程序是如何编译的，而不是其运行的机器类型。

+ 几乎所有的机器上，多<font color="red">字节</font>对象被存储为连续的<font color="red">字节</font>序列。字节是最小的可寻址单位

+ 大端小端

  + 问题引出：![mark](http://img.chenxinzouzou.cn/blog/20201123/214145830.jpg)

    最低有效<font color="red">字节</font>在最前面（最低有效地址）的方式，称为**小端法**。80x86 

    最高有效<font color="red">字节</font>在最前面（最低有效地址）的方式，称为**大端法**。IBM 360、MIPS

  示例：![大端小端](http://img.chenxinzouzou.cn/blog/20200828/220102729.png)

  + 字节顺序影响的三个地方
    + 不同类型之间通过网络传送二进制数时
    + 当阅读表示整数数据的字节序列时字节顺序也很重要

  + 当编写规避正常的类型系统的程序时，如强制类型转换

+ 计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来调试的辅助表以外。

+ ~   对应 NOT，& 对应AND ，| 对应OR，^ 对应异或（相同则为假，不同则为真）

![布尔运算](http://img.chenxinzouzou.cn/blog/20200828/214830867.jpg)

位向量的运算可以定义成参数的每个对应元素之间的运算

![mark](http://img.chenxinzouzou.cn/blog/20200828/220030872.jpg)

+ 位向量的一个重要运用就是表示有限集合，可用于屏蔽或使能信号（一个位代表一个信号），如计算机网络中的子网掩码

+ C中得移位操作符：

  + x<<k  ，x向左移k位，右端位补k个零

  + 右移分为两种

    +  x>>>k（Java），逻辑右移

      在左端补k个零

    + x>>k，算术右移

      在左端补k个最高有效位（符号位）的值

      ![移位运算](http://img.chenxinzouzou.cn/blog/20200828/220126319.jpg)

### 1.2 信息存储

#### 整数得编码

+ 无符号数编码的唯一性，函数B2W<sub>w</sub>，是一个双射。

+ 补码定义：![补码定义](http://img.chenxinzouzou.cn/blog/20200831/113113751.jpg)补码编码的最高有效位X<sub>w-1</sub>也称为符号位，它的“权重”为**-2<sup>w-1</sup>**，当符号位设置为1时，表示值为负数，当设置为0时，值为非负。

  补码编码的唯一性，B2T<sub>w</sub>是一个双射。

  补码是不对称的。

  关于整数数据类型的取值范围和表示，Java标准是非常明确的，它要求采用补码表示。在Java中，单字节数据类型称为byte而不是char。

+ 有符号数的其他表示方式

  ![有符号数的其他表示方式](http://img.chenxinzouzou.cn/blog/20200831/155755236.jpg)

  这两种表示方式都有一个奇怪的属性，那就是对数字0有两种不同的编码方式。浮点数中会使用原码编码。

+ 有符号数和无符号之间的转换

  + 一般的规则是：数值可能会改变，但是位模式不变，即改变的是计算机解释当前值的方式。

  + 在C语言中，当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号数参数强制转换为无符号数

    ![C语言的升级规则的效果](http://img.chenxinzouzou.cn/blog/20200831/204647807.jpg)

+ 拓展一个数字的位表示和截取一个数字

  + 无符号数的零拓展：直接在拓展高位补零
  + 补码数的符号拓展：拓展位全部补上原符号位的值
  + 截断无符号数：直接舍弃截断的位数，mod 操作
  + 截断补码数值：近似 mod 操作
  + 举个例子

### 1.3 整数运算

+ 无符号数加法

  + 无溢出则一切正常运算

  + 有溢出发生，舍去最高位，相当于结果是x+y-2<sup>w</sup>，2<sup>w</sup><=x+y<2<sup>w+1</sup>，实际是做了一个mod操作

  + 溢出的判定就是结果小于任一个加数

  + 列子

    假设w=4，能表示的范围为0000-1111（0-15），1101（13）+0101（5），结果为10110（18），此时结果为5位，这个时候就发生了溢出，舍去最高位位0110（3，即是18 mod 15），所以两个无符号数相加结果可能变小了。

+ 补码加法

  + 结果正溢出，则x+y的结果是 x+y-2<sup>w</sup>

  + 结果负溢出，则x+y的结果是 x+y+2<sup>w</sup>

  + 结果正常，则x+y的结果是 x+y

  + 补码加法的步骤：将其参数转换为无符号数吗，执行无符号加法，再将结果转换为补码

  + 列子

    假设w=4，能表示的范围为1000-0111（-8  -7），1101（-5）+1100（-4），结果为11001，此时结果为5位，这个时候就发生了负溢出，舍去最高位位1001（-1，即是-9 mod -8）；0101+0111（5+7），结果为1100（-4），发生了正溢出
  
+ 无符号数乘法

  + 两个w位的无符号数相乘可能会的到2w位数的结果，将结果截断w位，即x*y = （x\*y）mod 2<sup>w</sup>
  + 范围 0≤x×y≤(2<sup>w</sup>−1)<sup>2</sup>=2<sup>2w</sup>−2<sup>w+1</sup>+1

+ 补码乘法

  + 两个w位的有符号数相乘可能会的到2w位数的结果，将结果截断w位，相当相当做无符号数相乘，然后在把无符号数转换为补码
  + 无符号数和补码乘法的位级是等价的

### 1.4 浮点数

所有浮点数都可以用以下公式来表示：

$$\sum_{i=-n}^{m}10^d\times d_i$$

例如：

​	2$\frac {3}{4}$=10.11		7$\frac {7}{8}$=111.111   5$\frac {2}{4}$=101.1

二进制小数点向左移一位相当于这个数被除了一次2

但是这种定点表示法不能很有效的表示非常大的数字，例如$5\times2^100$.

#### 1.4.1 IEEE754浮点表示

+ $V=(-1)^s \; M \; 2^E$

+ s是符号，M是尾数，E是阶码

+ 标准浮点格式：

  ![标准浮点格式](http://img.chenxinzouzou.cn/blog/20200904/143204345.jpg)

+ 阶码的值决定了这个数是规格化的、非规格化的或特殊值

  + 规格化的值：当阶码的位模式**既不全是0也不全是1**，那么阶码的值是E = e-Bias，e是阶码位模式的无符号编码，Bias是一个等于2<sup>k-1</sup>-1（单精度是127，双精度是1023），之所以需要采用一个偏移量，是为了**保证阶码编码只需要以无符号数来处理**；尾数是M=1+f，M一定是以1开头的，可以把M看成是二进制表达是1.f<sub>n-1</sub>f<sub>n-2</sub>f<sub>n-3</sub>...f<sub>0</sub>，f<sub>n-1</sub>f<sub>n-2</sub>f<sub>n-3</sub>...f<sub>0</sub>部分就是frac编码的内容，那么当frac全为0时M最小=1，当frac全为1时M最大

    例如： 8位：0 001 1110  ,阶码3位，尾数4位，此时Bias =2<sup>(3-1)</sup>-1=3，所以E = 1-3=-2，M=1+$\frac {4}{8} $+$\frac {2}{8} $+$\frac {1}{8} $=$\frac {15}{8} $，V=$\frac {1}{4} $*$\frac {15}{8} $=$\frac {15}{32} $=0.46875

  + 非规格化的值：当**阶码域全0时**，阶码值是E = 1-Bias，尾数是M=f，就小数字段的值吗，不包含隐含的开头的1；

    非规格化数有两个用途：1、提供了一种数值0的表示方法；2、表示那些非常接近于0.0的数

    例如： 8位：0 000 1110  ,阶码3位，尾数4位，此时Bias =2<sup>(3-1)</sup>-1=3，所以E = **1**-3=-2，M=$\frac {4}{8} $+$\frac {2}{8} $+$\frac {1}{8} $=$\frac {7}{8} $，V=$\frac {1}{4} $*$\frac {7}{8} $=$\frac {7}{32} $=0.21875

  + 特殊值：**阶码全为1**，

    + 当**小数域全为0**时，得到的值表示无穷
    + 当**小数域为非0**时，得到的值为”NaN“，即不是一个数（Not a Number）
  

#### 1.4.2 舍入

+ 一共有四种舍入方式：

  ![浮点数舍入](http://img.chenxinzouzou.cn/blog/20200909/104749213.jpg)

+ 默认是用偶数舍去（最接近的值舍入）

  二进制例子：

  ```
    十进制值       二进制表示        					舍入
      2又3/4       10.11000            000型，向下舍入，10.10  （2又1/2）
      2又2/32      10.00010            小于100，向下舍入，10.00  （2）
      2又7/8       10.11100            刚好是100型，保证尾数是偶数，向上舍入，11.00  （3）
      2又5/8       10.10100            刚好是100型，保证尾数是偶数，向下舍入，10.10  （2又1/2）
  ```
  
  #### 1.4.3 浮点数加法
  
  

### 2 程序的机器级表示

#### 2.1 基础知识

 

#### 2.2 C到机器代码

+ 对机器编程来说，有两种抽象尤为重要：
  + 第一种是**指令集体系结构或指令集架构（Instruction Set  Architecture，ISA）**来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
  + 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的数组。

+ gcc将C代码转化为机器级代码:

  ``` shell
  [root@hw]gcc -Og -o p p1.c p2.c
  ```

  + 首先C预处理器拓展源代码，然后编译器产生源文件的汇编代码，分别为p1.s，p2.s
  + 汇编器将汇编代码转化为二进制目标代码文件p1.o，p2.o；目标代码是机器码的一种形式，它包含所有的二进制表示，但是还没有填入全局值的地址
  + 链接器将两个目标代码文件与实现库函数的代码合并，并产生最终的可执行代码文件p，可执行代码是机器代码的第二种形式，也就是处理器执行的代码格式

+ 示例：

  先有一个hello.c文件，文件如下：

  ```c
  int main()
  {
     p();
     return 0;
  }
  
  void p(){
     printf("hello ,zou zou\n");
  }
  ```

  在命令行上使用“-S”选项，就能看到C语言编译器产生的汇编代码（编译）：

  ```shell
  [root@hw]gcc -Og -S hello.c
  ```

  产生的hello.s就是汇编代码，可查看。

  ![编译结果（汇编代码，部分）](http://img.chenxinzouzou.cn/blog/20200911/130415496.jpg)

  如果在命令行上使用“-c”选项，GCC会编译并**汇编**该代码

  ```shell
  [root@hw]gcc -Og -c hello.c
  ```

  产生的hello.o是二进制格式的，无法直接查看，可以会用反汇编器OBJDUMP（这都什么鬼~）：

  ```shell
  [root@hw]objdump -d hello.o
  ```

  ![反汇编结果](http://img.chenxinzouzou.cn/blog/20200911/130234789.jpg)
#### 2.3 控制

+ 常见的跳转指令：

![mark](http://img.chenxinzouzou.cn/blog/20201214/202127574.jpg)

##### 2.3.1 通过条件控制来实现条件分支

##### 2.3.2 通过条件传送来实现条件分支

​		条件传送实现的条件分支比条件控制方法性能更好，因为现在的处理器处理指令都是通过"流水线（pipelining）"来获得高性能的，”流水线”：处理器执行指令分了分多个步骤，当第一个条指令执行第一个步骤完的时候后一条指令就跟着执行后一条指令的第一个步骤，这样就能大大提高性能；但是使用条件控制实现的条件分支，因为前面的指令执行分支不确定，所以就不确定后面跟着执行的指令是哪些，也就无法完成“流水线”。

​		为了更好的进行“流水线“，可以使用分支预测逻辑技术。

​		条件传送回带来更多的计算代价。

#### 2.4 过程

##### 2.4.1 过程调用要素概述

+ 过程就是函数调用或者说方法调用。绝大多数语言包括C语言都是用栈来实现的。

+ %rsp 寄存器都是存的栈的栈顶，栈都是高地址在栈底一端，低地址在栈顶一端，所以  %rsp -8 就代表在栈上分配8字节的空间，%rsp+8,代表在栈上回收8字节的空间


+ 假设过程P调用过程Q，这些个工作要包含以下一个或多个动作：

  + 传递控制，通过设置PC的值为Q的第一个指令的地址调起Q，在Q调用完后则要将PC设置为P调用Q的下一条指令（**返回地址**）

  + 传递数据，即参数传递

  + 分配和释放内存，调用过程Q的时候可能需要为Q分配存放参数和局部变量的栈空间，Q执行结束后需要释放掉这一部分的空间，内存的分配和释放对应对应的栈顶（%rsp 寄存器）的**减和加**
+ 当X86-64的过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分称为过程的**栈帧（stack fram）**
+ 

##### 2.4.2 传递控制

实现传递控制主要是**call**和**ret**指令：

+ call指令：该指令会把call指令后面的指令地址A压入栈中，并将PC设置为Q的起始地址，压入的地址A就是**返回地址**
+ ret 指令：该指令会从当前过程返回，将PC的值设置为返回地址

##### 2.4.3 传递数据

+ X86-64中，寄存器最多只能存6个整型参数，寄存器是用的名字取决于要传递的数据类型的大小。

+ 如果一个函数有大于6个整形参数，超出6个的部分就要通过栈来传递。
+ 寄存器的使用是有惯例的：
  + 寄存器%**rbx、%rbp和%r12-%r15**被划分为**被调用者保存寄存器**，当过程P调用过程Q时，Q必须保存这些寄存器的值。
  + 所有的其他寄存器，除了**栈指针%rsp**，都分类为调用者保存寄存器。

##### 2.4.4 例子 

C代码如下：

```c
#include <stdio.h>
long swap_add(long *xp, long *yp) {
    long x = *xp;
    long y = *yp;
    *xp = y;
    *yp = x;
    return x + y;
}
void call(){
    long arg1 = 534;
    long arg2 = 1057;
    long sum = swap_add(&arg1, &arg2);
    long diff = arg1 - arg2;
}
int main() {
    call();
}
```

使用下面的命令编译并汇编该代码

```
gcc -Og -c .\main.c
```

得到main.o，再使用查看

```objdump -d main.o
objdump -d main.o
```

```main.o:     file format pe-x86-64
Disassembly of section .text:
0000000000000000 <swap_add>:
   0:   8b 01                   mov    (%rcx),%eax
   2:   44 8b 02                mov    (%rdx),%r8d
   5:   44 89 01                mov    %r8d,(%rcx)
   8:   89 02                   mov    %eax,(%rdx)
   a:   44 01 c0                add    %r8d,%eax
   d:   c3                      retq
000000000000000e <call>:
   e:   48 83 ec 38             sub    $0x38,%rsp
  12:   c7 44 24 2c 16 02 00    movl   $0x216,0x2c(%rsp)
  19:   00
  1a:   c7 44 24 28 21 04 00    movl   $0x421,0x28(%rsp)
  21:   00
  22:   48 8d 54 24 28          lea    0x28(%rsp),%rdx
  27:   48 8d 4c 24 2c          lea    0x2c(%rsp),%rcx
  2c:   e8 cf ff ff ff          callq  0 <swap_add>
  31:   90                      nop
  32:   48 83 c4 38             add    $0x38,%rsp
  36:   c3                      retq
0000000000000037 <main>:
  37:   48 83 ec 28             sub    $0x28,%rsp
  3b:   e8 00 00 00 00          callq  40 <main+0x9>
  40:   e8 c9 ff ff ff          callq  e <call>
  45:   b8 00 00 00 00          mov    $0x0,%eax
  4a:   48 83 c4 28             add    $0x28,%rsp
  4e:   c3                      retq
  4f:   90                      nop
```


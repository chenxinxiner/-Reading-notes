# 深入理解计算机组成原理

## 程序结构和执行

### 1 信息的表示和处理

### 1.1 信息存储

+ 我们将程序称为“32位程序”或“64位程序”时，区别是该程序是如何编译的，而不是其运行的机器类型。

+ 几乎所有的机器上，多<font color="red">字节</font>对象被存储为连续的<font color="red">字节</font>序列。字节是最小的可寻址单位

+ 大端小端

  + 问题引出：![mark](http://img.chenxinzouzou.cn/blog/20201123/214145830.jpg)

    最低有效<font color="red">字节</font>在最前面（最低有效地址）的方式，称为**小端法**。80x86 

    最高有效<font color="red">字节</font>在最前面（最低有效地址）的方式，称为**大端法**。IBM 360、MIPS

  示例：![大端小端](http://img.chenxinzouzou.cn/blog/20200828/220102729.png)

  + 字节顺序影响的三个地方
    + 不同类型之间通过网络传送二进制数时
    + 当阅读表示整数数据的字节序列时字节顺序也很重要

  + 当编写规避正常的类型系统的程序时，如强制类型转换

+ 计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了可能有些用来调试的辅助表以外。

+ ~   对应 NOT，& 对应AND ，| 对应OR，^ 对应异或（相同则为假，不同则为真）

![布尔运算](http://img.chenxinzouzou.cn/blog/20200828/214830867.jpg)

位向量的运算可以定义成参数的每个对应元素之间的运算

![mark](http://img.chenxinzouzou.cn/blog/20200828/220030872.jpg)

+ 位向量的一个重要运用就是表示有限集合，可用于屏蔽或使能信号（一个位代表一个信号），如计算机网络中的子网掩码

+ C中得移位操作符：

  + x<<k  ，x向左移k位，右端位补k个零

  + 右移分为两种

    +  x>>>k（Java），逻辑右移

      在左端补k个零

    + x>>k，算术右移

      在左端补k个最高有效位（符号位）的值

      ![移位运算](http://img.chenxinzouzou.cn/blog/20200828/220126319.jpg)

### 1.2 信息存储

#### 整数得编码

+ 无符号数编码的唯一性，函数B2W<sub>w</sub>，是一个双射。

+ 补码定义：![补码定义](http://img.chenxinzouzou.cn/blog/20200831/113113751.jpg)补码编码的最高有效位X<sub>w-1</sub>也称为符号位，它的“权重”为**-2<sup>w-1</sup>**，当符号位设置为1时，表示值为负数，当设置为0时，值为非负。

  补码编码的唯一性，B2T<sub>w</sub>是一个双射。

  补码是不对称的。

  关于整数数据类型的取值范围和表示，Java标准是非常明确的，它要求采用补码表示。在Java中，单字节数据类型称为byte而不是char。

+ 有符号数的其他表示方式

  ![有符号数的其他表示方式](http://img.chenxinzouzou.cn/blog/20200831/155755236.jpg)

  这两种表示方式都有一个奇怪的属性，那就是对数字0有两种不同的编码方式。浮点数中会使用原码编码。

+ 有符号数和无符号之间的转换

  + 一般的规则是：数值可能会改变，但是位模式不变，即改变的是计算机解释当前值的方式。

  + 在C语言中，当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号数参数强制转换为无符号数

    ![C语言的升级规则的效果](http://img.chenxinzouzou.cn/blog/20200831/204647807.jpg)

+ 拓展一个数字的位表示和截取一个数字

  + 无符号数的零拓展：直接在拓展高位补零
  + 补码数的符号拓展：拓展位全部补上原符号位的值
  + 截断无符号数：直接舍弃截断的位数，mod 操作
  + 截断补码数值：近似 mod 操作
  + 举个例子

### 1.3 整数运算

+ 无符号数加法

  + 无溢出则一切正常运算

  + 有溢出发生，舍去最高位，相当于结果是x+y-2<sup>w</sup>，2<sup>w</sup><=x+y<2<sup>w+1</sup>，实际是做了一个mod操作

  + 溢出的判定就是结果小于任一个加数

  + 列子

    假设w=4，能表示的范围为0000-1111（0-15），1101（13）+0101（5），结果为10110（18），此时结果为5位，这个时候就发生了溢出，舍去最高位位0110（3，即是18 mod 15），所以两个无符号数相加结果可能变小了。

+ 补码加法

  + 结果正溢出，则x+y的结果是 x+y-2<sup>w</sup>

  + 结果负溢出，则x+y的结果是 x+y+2<sup>w</sup>

  + 结果正常，则x+y的结果是 x+y

  + 补码加法的步骤：将其参数转换为无符号数吗，执行无符号加法，再将结果转换为补码

  + 列子

    假设w=4，能表示的范围为1000-0111（-8  -7），1101（-5）+1100（-4），结果为11001，此时结果为5位，这个时候就发生了负溢出，舍去最高位位1001（-1，即是-9 mod -8）；0101+0111（5+7），结果为1100（-4），发生了正溢出
  
+ 无符号数乘法

  + 两个w位的无符号数相乘可能会的到2w位数的结果，将结果截断w位，即x*y = （x\*y）mod 2<sup>w</sup>
  + 范围 0≤x×y≤(2<sup>w</sup>−1)<sup>2</sup>=2<sup>2w</sup>−2<sup>w+1</sup>+1

+ 补码乘法

  + 两个w位的有符号数相乘可能会的到2w位数的结果，将结果截断w位，相当相当做无符号数相乘，然后在把无符号数转换为补码
  + 无符号数和补码乘法的位级是等价的

### 1.4 浮点数

所有浮点数都可以用以下公式来表示：

$$\sum_{i=-n}^{m}10^d\times d_i$$

例如：

​	2$\frac {3}{4}$=10.11		7$\frac {7}{8}$=111.111   5$\frac {2}{4}$=101.1

二进制小数点向左移一位相当于这个数被除了一次2

但是这种定点表示法不能很有效的表示非常大的数字，例如$5\times2^100$.

#### 1.4.1 IEEE754浮点表示

+ $V=(-1)^s \; M \; 2^E$

+ s是符号，M是尾数，E是阶码

+ 标准浮点格式：

  ![标准浮点格式](http://img.chenxinzouzou.cn/blog/20200904/143204345.jpg)

+ 阶码的值决定了这个数是规格化的、非规格化的或特殊值

  + 规格化的值：当阶码的位模式**既不全是0也不全是1**，那么阶码的值是E = e-Bias，e是阶码位模式的无符号编码，Bias是一个等于2<sup>k-1</sup>-1（单精度是127，双精度是1023），之所以需要采用一个偏移量，是为了**保证阶码编码只需要以无符号数来处理**；尾数是M=1+f，M一定是以1开头的，可以把M看成是二进制表达是1.f<sub>n-1</sub>f<sub>n-2</sub>f<sub>n-3</sub>...f<sub>0</sub>，f<sub>n-1</sub>f<sub>n-2</sub>f<sub>n-3</sub>...f<sub>0</sub>部分就是frac编码的内容，那么当frac全为0时M最小=1，当frac全为1时M最大

    例如： 8位：0 001 1110  ,阶码3位，尾数4位，此时Bias =2<sup>(3-1)</sup>-1=3，所以E = 1-3=-2，M=1+$\frac {4}{8} $+$\frac {2}{8} $+$\frac {1}{8} $=$\frac {15}{8} $，V=$\frac {1}{4} $*$\frac {15}{8} $=$\frac {15}{32} $=0.46875

  + 非规格化的值：当**阶码域全0时**，阶码值是E = 1-Bias，尾数是M=f，就小数字段的值吗，不包含隐含的开头的1；

    非规格化数有两个用途：1、提供了一种数值0的表示方法；2、表示那些非常接近于0.0的数

    例如： 8位：0 000 1110  ,阶码3位，尾数4位，此时Bias =2<sup>(3-1)</sup>-1=3，所以E = **1**-3=-2，M=$\frac {4}{8} $+$\frac {2}{8} $+$\frac {1}{8} $=$\frac {7}{8} $，V=$\frac {1}{4} $*$\frac {7}{8} $=$\frac {7}{32} $=0.21875

  + 特殊值：**阶码全为1**，

    + 当**小数域全为0**时，得到的值表示无穷
    + 当**小数域为非0**时，得到的值为”NaN“，即不是一个数（Not a Number）
  

#### 1.4.2 舍入

+ 一共有四种舍入方式：

  ![浮点数舍入](http://img.chenxinzouzou.cn/blog/20200909/104749213.jpg)

+ 默认是用偶数舍去（最接近的值舍入）

  二进制例子：

  ```
    十进制值       二进制表示        					舍入
      2又3/4       10.11000            000型，向下舍入，10.10  （2又1/2）
      2又2/32      10.00010            小于100，向下舍入，10.00  （2）
      2又7/8       10.11100            刚好是100型，保证尾数是偶数，向上舍入，11.00  （3）
      2又5/8       10.10100            刚好是100型，保证尾数是偶数，向下舍入，10.10  （2又1/2）
  ```
  
  #### 1.4.3 浮点数加法
  
  

### 2 程序的机器级表示

### 2.1 基础知识

 

#### 2.2 C到机器代码

+ 对机器编程来说，有两种抽象尤为重要：
  + 第一种是**指令集体系结构或指令集架构（Instruction Set  Architecture，ISA）**来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
  + 第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的数组。

+ gcc将C代码转化为机器级代码:

  ``` shell
  [root@hw]gcc -Og -o p p1.c p2.c
  ```

  + 首先C预处理器拓展源代码，然后编译器产生源文件的汇编代码，分别为p1.s，p2.s
  + 汇编器将汇编代码转化为二进制目标代码文件p1.o，p2.o；目标代码是机器码的一种形式，它包含所有的二进制表示，但是还没有填入全局值的地址
  + 链接器将两个目标代码文件与实现库函数的代码合并，并产生最终的可执行代码文件p，可执行代码是机器代码的第二种形式，也就是处理器执行的代码格式

+ 示例：

  先有一个hello.c文件，文件如下：

  ```c
  int main()
  {
     p();
     return 0;
  }
  
  void p(){
     printf("hello ,zou zou\n");
  }
  ```

  在命令行上使用“-S”选项，就能看到C语言编译器产生的汇编代码：

  ```shell
  [root@hw]gcc -Og -S hello.c
  ```

  产生的hello.s就是汇编代码，可查看。

  ![编译结果（汇编代码，部分）](http://img.chenxinzouzou.cn/blog/20200911/130415496.jpg)

  如果在命令行上使用“-c”选项，GCC会编译并汇编该代码

  ```shell
  [root@hw]gcc -Og -c hello.c
  ```

  产生的hello.o是二进制格式的，无法直接查看，可以会用反汇编器OBJDUMP（这都什么鬼~）：

  ```shell
  [root@hw]objdump -d hello.o
  ```

  ![反汇编结果](http://img.chenxinzouzou.cn/blog/20200911/130234789.jpg)
#### 2.3 控制

+ 常见的跳转指令：

![mark](http://img.chenxinzouzou.cn/blog/20201214/202127574.jpg)

